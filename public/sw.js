var __wpo = {
  "assets": {
    "main": [
      "./javascript/0-b2384cad.chunk.js",
      "./css/main.css",
      "./javascript/main.js",
      "./valisette-logo.png",
      "./"
    ],
    "additional": [],
    "optional": []
  },
  "externals": [],
  "hashesMap": {
    "e3f9b6890840b6760673c274fb3acdac8e6ee8bb": "./javascript/0-b2384cad.chunk.js",
    "cf2b0546bb42498e6de99bcfe3c4a1bb03745b0f": "./css/main.css",
    "f9225c028cfe65f3123e767fb67f563fc1eb3ec2": "./javascript/main.js",
    "30747e7601571f8e893c55cd7ac6c166869ae921": "./valisette-logo.png",
    "1a90622f3253587912c5d878538e8886d90e688c": "./"
  },
  "strategy": "changed",
  "responseStrategy": "cache-first",
  "version": "3/28/2019, 6:59:25 PM",
  "name": "webpack-offline",
  "pluginVersion": "5.0.6",
  "relativePaths": true
};

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/index.html%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./node_modules/offline-plugin/tpls/empty-entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/index.html%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./node_modules/offline-plugin/tpls/empty-entry.js":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/index.html%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./node_modules/offline-plugin/tpls/empty-entry.js ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var waitUntil = ExtendableEvent.prototype.waitUntil;\n  var respondWith = FetchEvent.prototype.respondWith;\n  var promisesMap = new WeakMap();\n\n  ExtendableEvent.prototype.waitUntil = function (promise) {\n    var extendableEvent = this;\n    var promises = promisesMap.get(extendableEvent);\n\n    if (promises) {\n      promises.push(Promise.resolve(promise));\n      return;\n    }\n\n    promises = [Promise.resolve(promise)];\n    promisesMap.set(extendableEvent, promises);\n\n    // call original method\n    return waitUntil.call(extendableEvent, Promise.resolve().then(function processPromises() {\n      var len = promises.length;\n\n      // wait for all to settle\n      return Promise.all(promises.map(function (p) {\n        return p[\"catch\"](function () {});\n      })).then(function () {\n        // have new items been added? If so, wait again\n        if (promises.length != len) return processPromises();\n        // we're done!\n        promisesMap[\"delete\"](extendableEvent);\n        // reject if one of the promises rejected\n        return Promise.all(promises);\n      });\n    }));\n  };\n\n  FetchEvent.prototype.respondWith = function (promise) {\n    this.waitUntil(promise);\n    return respondWith.call(this, promise);\n  };\n})();;\n        'use strict';\n\nif (typeof DEBUG === 'undefined') {\n  var DEBUG = false;\n}\n\nfunction WebpackServiceWorker(params, helpers) {\n  var cacheMaps = helpers.cacheMaps;\n  // navigationPreload: true, { map: (URL) => URL, test: (URL) => boolean }\n  var navigationPreload = helpers.navigationPreload;\n\n  // (update)strategy: changed, all\n  var strategy = params.strategy;\n  // responseStrategy: cache-first, network-first\n  var responseStrategy = params.responseStrategy;\n\n  var assets = params.assets;\n\n  var hashesMap = params.hashesMap;\n  var externals = params.externals;\n\n  var prefetchRequest = params.prefetchRequest || {\n    credentials: 'same-origin',\n    mode: 'cors'\n  };\n\n  var CACHE_PREFIX = params.name;\n  var CACHE_TAG = params.version;\n  var CACHE_NAME = CACHE_PREFIX + ':' + CACHE_TAG;\n\n  var PRELOAD_CACHE_NAME = CACHE_PREFIX + '$preload';\n  var STORED_DATA_KEY = '__offline_webpack__data';\n\n  mapAssets();\n\n  var allAssets = [].concat(assets.main, assets.additional, assets.optional);\n\n  self.addEventListener('install', function (event) {\n    console.log('[SW]:', 'Install event');\n\n    var installing = undefined;\n\n    if (strategy === 'changed') {\n      installing = cacheChanged('main');\n    } else {\n      installing = cacheAssets('main');\n    }\n\n    event.waitUntil(installing);\n  });\n\n  self.addEventListener('activate', function (event) {\n    console.log('[SW]:', 'Activate event');\n\n    var activation = cacheAdditional();\n\n    // Delete all assets which name starts with CACHE_PREFIX and\n    // is not current cache (CACHE_NAME)\n    activation = activation.then(storeCacheData);\n    activation = activation.then(deleteObsolete);\n    activation = activation.then(function () {\n      if (self.clients && self.clients.claim) {\n        return self.clients.claim();\n      }\n    });\n\n    if (navigationPreload && self.registration.navigationPreload) {\n      activation = Promise.all([activation, self.registration.navigationPreload.enable()]);\n    }\n\n    event.waitUntil(activation);\n  });\n\n  function cacheAdditional() {\n    if (!assets.additional.length) {\n      return Promise.resolve();\n    }\n\n    if (DEBUG) {\n      console.log('[SW]:', 'Caching additional');\n    }\n\n    var operation = undefined;\n\n    if (strategy === 'changed') {\n      operation = cacheChanged('additional');\n    } else {\n      operation = cacheAssets('additional');\n    }\n\n    // Ignore fail of `additional` cache section\n    return operation['catch'](function (e) {\n      console.error('[SW]:', 'Cache section `additional` failed to load');\n    });\n  }\n\n  function cacheAssets(section) {\n    var batch = assets[section];\n\n    return caches.open(CACHE_NAME).then(function (cache) {\n      return addAllNormalized(cache, batch, {\n        bust: params.version,\n        request: prefetchRequest,\n        failAll: section === 'main'\n      });\n    }).then(function () {\n      logGroup('Cached assets: ' + section, batch);\n    })['catch'](function (e) {\n      console.error(e);\n      throw e;\n    });\n  }\n\n  function cacheChanged(section) {\n    return getLastCache().then(function (args) {\n      if (!args) {\n        return cacheAssets(section);\n      }\n\n      var lastCache = args[0];\n      var lastKeys = args[1];\n      var lastData = args[2];\n\n      var lastMap = lastData.hashmap;\n      var lastVersion = lastData.version;\n\n      if (!lastData.hashmap || lastVersion === params.version) {\n        return cacheAssets(section);\n      }\n\n      var lastHashedAssets = Object.keys(lastMap).map(function (hash) {\n        return lastMap[hash];\n      });\n\n      var lastUrls = lastKeys.map(function (req) {\n        var url = new URL(req.url);\n        url.search = '';\n        url.hash = '';\n\n        return url.toString();\n      });\n\n      var sectionAssets = assets[section];\n      var moved = [];\n      var changed = sectionAssets.filter(function (url) {\n        if (lastUrls.indexOf(url) === -1 || lastHashedAssets.indexOf(url) === -1) {\n          return true;\n        }\n\n        return false;\n      });\n\n      Object.keys(hashesMap).forEach(function (hash) {\n        var asset = hashesMap[hash];\n\n        // Return if not in sectionAssets or in changed or moved array\n        if (sectionAssets.indexOf(asset) === -1 || changed.indexOf(asset) !== -1 || moved.indexOf(asset) !== -1) return;\n\n        var lastAsset = lastMap[hash];\n\n        if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {\n          moved.push([lastAsset, asset]);\n        } else {\n          changed.push(asset);\n        }\n      });\n\n      logGroup('Changed assets: ' + section, changed);\n      logGroup('Moved assets: ' + section, moved);\n\n      var movedResponses = Promise.all(moved.map(function (pair) {\n        return lastCache.match(pair[0]).then(function (response) {\n          return [pair[1], response];\n        });\n      }));\n\n      return caches.open(CACHE_NAME).then(function (cache) {\n        var move = movedResponses.then(function (responses) {\n          return Promise.all(responses.map(function (pair) {\n            return cache.put(pair[0], pair[1]);\n          }));\n        });\n\n        return Promise.all([move, addAllNormalized(cache, changed, {\n          bust: params.version,\n          request: prefetchRequest,\n          failAll: section === 'main',\n          deleteFirst: section !== 'main'\n        })]);\n      });\n    });\n  }\n\n  function deleteObsolete() {\n    return caches.keys().then(function (keys) {\n      var all = keys.map(function (key) {\n        if (key.indexOf(CACHE_PREFIX) !== 0 || key.indexOf(CACHE_NAME) === 0) return;\n\n        console.log('[SW]:', 'Delete cache:', key);\n        return caches['delete'](key);\n      });\n\n      return Promise.all(all);\n    });\n  }\n\n  function getLastCache() {\n    return caches.keys().then(function (keys) {\n      var index = keys.length;\n      var key = undefined;\n\n      while (index--) {\n        key = keys[index];\n\n        if (key.indexOf(CACHE_PREFIX) === 0) {\n          break;\n        }\n      }\n\n      if (!key) return;\n\n      var cache = undefined;\n\n      return caches.open(key).then(function (_cache) {\n        cache = _cache;\n        return _cache.match(new URL(STORED_DATA_KEY, location).toString());\n      }).then(function (response) {\n        if (!response) return;\n\n        return Promise.all([cache, cache.keys(), response.json()]);\n      });\n    });\n  }\n\n  function storeCacheData() {\n    return caches.open(CACHE_NAME).then(function (cache) {\n      var data = new Response(JSON.stringify({\n        version: params.version,\n        hashmap: hashesMap\n      }));\n\n      return cache.put(new URL(STORED_DATA_KEY, location).toString(), data);\n    });\n  }\n\n  self.addEventListener('fetch', function (event) {\n    // Handle only GET requests\n    if (event.request.method !== 'GET') {\n      return;\n    }\n\n    // This prevents some weird issue with Chrome DevTools and 'only-if-cached'\n    // Fixes issue #385, also ref to:\n    // - https://github.com/paulirish/caltrainschedule.io/issues/49\n    // - https://bugs.chromium.org/p/chromium/issues/detail?id=823392\n    if (event.request.cache === 'only-if-cached' && event.request.mode !== 'same-origin') {\n      return;\n    }\n\n    var url = new URL(event.request.url);\n    url.hash = '';\n\n    var urlString = url.toString();\n\n    // Not external, so search part of the URL should be stripped,\n    // if it's external URL, the search part should be kept\n    if (externals.indexOf(urlString) === -1) {\n      url.search = '';\n      urlString = url.toString();\n    }\n\n    var assetMatches = allAssets.indexOf(urlString) !== -1;\n    var cacheUrl = urlString;\n\n    if (!assetMatches) {\n      var cacheRewrite = matchCacheMap(event.request);\n\n      if (cacheRewrite) {\n        cacheUrl = cacheRewrite;\n        assetMatches = true;\n      }\n    }\n\n    if (!assetMatches) {\n      // Use request.mode === 'navigate' instead of isNavigateRequest\n      // because everything what supports navigationPreload supports\n      // 'navigate' request.mode\n      if (event.request.mode === 'navigate') {\n        // Requesting with fetchWithPreload().\n        // Preload is used only if navigationPreload is enabled and\n        // navigationPreload mapping is not used.\n        if (navigationPreload === true) {\n          event.respondWith(fetchWithPreload(event));\n          return;\n        }\n      }\n\n      // Something else, positive, but not `true`\n      if (navigationPreload) {\n        var preloadedResponse = retrivePreloadedResponse(event);\n\n        if (preloadedResponse) {\n          event.respondWith(preloadedResponse);\n          return;\n        }\n      }\n\n      // Logic exists here if no cache match\n      return;\n    }\n\n    // Cache handling/storing/fetching starts here\n    var resource = undefined;\n\n    if (responseStrategy === 'network-first') {\n      resource = networkFirstResponse(event, urlString, cacheUrl);\n    }\n    // 'cache-first' otherwise\n    // (responseStrategy has been validated before)\n    else {\n        resource = cacheFirstResponse(event, urlString, cacheUrl);\n      }\n\n    event.respondWith(resource);\n  });\n\n  self.addEventListener('message', function (e) {\n    var data = e.data;\n    if (!data) return;\n\n    switch (data.action) {\n      case 'skipWaiting':\n        {\n          if (self.skipWaiting) self.skipWaiting();\n        }break;\n    }\n  });\n\n  function cacheFirstResponse(event, urlString, cacheUrl) {\n    handleNavigationPreload(event);\n\n    return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {\n      if (response) {\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + cacheUrl + '](' + urlString + ') from cache');\n        }\n\n        return response;\n      }\n\n      // Load and cache known assets\n      var fetching = fetch(event.request).then(function (response) {\n        if (!response.ok) {\n          if (DEBUG) {\n            console.log('[SW]:', 'URL [' + urlString + '] wrong response: [' + response.status + '] ' + response.type);\n          }\n\n          return response;\n        }\n\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + urlString + '] from network');\n        }\n\n        if (cacheUrl === urlString) {\n          (function () {\n            var responseClone = response.clone();\n            var storing = caches.open(CACHE_NAME).then(function (cache) {\n              return cache.put(urlString, responseClone);\n            }).then(function () {\n              console.log('[SW]:', 'Cache asset: ' + urlString);\n            });\n\n            event.waitUntil(storing);\n          })();\n        }\n\n        return response;\n      });\n\n      return fetching;\n    });\n  }\n\n  function networkFirstResponse(event, urlString, cacheUrl) {\n    return fetchWithPreload(event).then(function (response) {\n      if (response.ok) {\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + urlString + '] from network');\n        }\n\n        return response;\n      }\n\n      // Throw to reach the code in the catch below\n      throw response;\n    })\n    // This needs to be in a catch() and not just in the then() above\n    // cause if your network is down, the fetch() will throw\n    ['catch'](function (erroredResponse) {\n      if (DEBUG) {\n        console.log('[SW]:', 'URL [' + urlString + '] from cache if possible');\n      }\n\n      return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {\n        if (response) {\n          return response;\n        }\n\n        if (erroredResponse instanceof Response) {\n          return erroredResponse;\n        }\n\n        // Not a response at this point, some other error\n        throw erroredResponse;\n        // return Response.error();\n      });\n    });\n  }\n\n  function handleNavigationPreload(event) {\n    if (navigationPreload && typeof navigationPreload.map === 'function' &&\n    // Use request.mode === 'navigate' instead of isNavigateRequest\n    // because everything what supports navigationPreload supports\n    // 'navigate' request.mode\n    event.preloadResponse && event.request.mode === 'navigate') {\n      var mapped = navigationPreload.map(new URL(event.request.url), event.request);\n\n      if (mapped) {\n        storePreloadedResponse(mapped, event);\n      }\n    }\n  }\n\n  // Temporary in-memory store for faster access\n  var navigationPreloadStore = new Map();\n\n  function storePreloadedResponse(_url, event) {\n    var url = new URL(_url, location);\n    var preloadResponsePromise = event.preloadResponse;\n\n    navigationPreloadStore.set(preloadResponsePromise, {\n      url: url,\n      response: preloadResponsePromise\n    });\n\n    var isSamePreload = function isSamePreload() {\n      return navigationPreloadStore.has(preloadResponsePromise);\n    };\n\n    var storing = preloadResponsePromise.then(function (res) {\n      // Return if preload isn't enabled or hasn't happened\n      if (!res) return;\n\n      // If navigationPreloadStore already consumed\n      // or navigationPreloadStore already contains another preload,\n      // then do not store anything and return\n      if (!isSamePreload()) {\n        return;\n      }\n\n      var clone = res.clone();\n\n      // Storing the preload response for later consume (hasn't yet been consumed)\n      return caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n        if (!isSamePreload()) return;\n\n        return cache.put(url, clone).then(function () {\n          if (!isSamePreload()) {\n            return caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n              return cache['delete'](url);\n            });\n          }\n        });\n      });\n    });\n\n    event.waitUntil(storing);\n  }\n\n  function retriveInMemoryPreloadedResponse(url) {\n    if (!navigationPreloadStore) {\n      return;\n    }\n\n    var foundResponse = undefined;\n    var foundKey = undefined;\n\n    navigationPreloadStore.forEach(function (store, key) {\n      if (store.url.href === url.href) {\n        foundResponse = store.response;\n        foundKey = key;\n      }\n    });\n\n    if (foundResponse) {\n      navigationPreloadStore['delete'](foundKey);\n      return foundResponse;\n    }\n  }\n\n  function retrivePreloadedResponse(event) {\n    var url = new URL(event.request.url);\n\n    if (self.registration.navigationPreload && navigationPreload && navigationPreload.test && navigationPreload.test(url, event.request)) {} else {\n      return;\n    }\n\n    var fromMemory = retriveInMemoryPreloadedResponse(url);\n    var request = event.request;\n\n    if (fromMemory) {\n      event.waitUntil(caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n        return cache['delete'](request);\n      }));\n\n      return fromMemory;\n    }\n\n    return cachesMatch(request, PRELOAD_CACHE_NAME).then(function (response) {\n      if (response) {\n        event.waitUntil(caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n          return cache['delete'](request);\n        }));\n      }\n\n      return response || fetch(event.request);\n    });\n  }\n\n  function mapAssets() {\n    Object.keys(assets).forEach(function (key) {\n      assets[key] = assets[key].map(function (path) {\n        var url = new URL(path, location);\n\n        url.hash = '';\n\n        if (externals.indexOf(path) === -1) {\n          url.search = '';\n        }\n\n        return url.toString();\n      });\n    });\n\n    hashesMap = Object.keys(hashesMap).reduce(function (result, hash) {\n      var url = new URL(hashesMap[hash], location);\n      url.search = '';\n      url.hash = '';\n\n      result[hash] = url.toString();\n      return result;\n    }, {});\n\n    externals = externals.map(function (path) {\n      var url = new URL(path, location);\n      url.hash = '';\n\n      return url.toString();\n    });\n  }\n\n  function addAllNormalized(cache, requests, options) {\n    var bustValue = options.bust;\n    var failAll = options.failAll !== false;\n    var deleteFirst = options.deleteFirst === true;\n    var requestInit = options.request || {\n      credentials: 'omit',\n      mode: 'cors'\n    };\n\n    var deleting = Promise.resolve();\n\n    if (deleteFirst) {\n      deleting = Promise.all(requests.map(function (request) {\n        return cache['delete'](request)['catch'](function () {});\n      }));\n    }\n\n    return Promise.all(requests.map(function (request) {\n      if (bustValue) {\n        request = applyCacheBust(request, bustValue);\n      }\n\n      return fetch(request, requestInit).then(fixRedirectedResponse).then(function (response) {\n        if (!response.ok) {\n          return { error: true };\n        }\n\n        return { response: response };\n      }, function () {\n        return { error: true };\n      });\n    })).then(function (responses) {\n      if (failAll && responses.some(function (data) {\n        return data.error;\n      })) {\n        return Promise.reject(new Error('Wrong response status'));\n      }\n\n      if (!failAll) {\n        responses = responses.filter(function (data) {\n          return !data.error;\n        });\n      }\n\n      return deleting.then(function () {\n        var addAll = responses.map(function (_ref, i) {\n          var response = _ref.response;\n\n          return cache.put(requests[i], response);\n        });\n\n        return Promise.all(addAll);\n      });\n    });\n  }\n\n  function matchCacheMap(request) {\n    var urlString = request.url;\n    var url = new URL(urlString);\n\n    var requestType = undefined;\n\n    if (isNavigateRequest(request)) {\n      requestType = 'navigate';\n    } else if (url.origin === location.origin) {\n      requestType = 'same-origin';\n    } else {\n      requestType = 'cross-origin';\n    }\n\n    for (var i = 0; i < cacheMaps.length; i++) {\n      var map = cacheMaps[i];\n\n      if (!map) continue;\n      if (map.requestTypes && map.requestTypes.indexOf(requestType) === -1) {\n        continue;\n      }\n\n      var newString = undefined;\n\n      if (typeof map.match === 'function') {\n        newString = map.match(url, request);\n      } else {\n        newString = urlString.replace(map.match, map.to);\n      }\n\n      if (newString && newString !== urlString) {\n        return newString;\n      }\n    }\n  }\n\n  function fetchWithPreload(event) {\n    if (!event.preloadResponse || navigationPreload !== true) {\n      return fetch(event.request);\n    }\n\n    return event.preloadResponse.then(function (response) {\n      return response || fetch(event.request);\n    });\n  }\n}\n\nfunction cachesMatch(request, cacheName) {\n  return caches.match(request, {\n    cacheName: cacheName\n  }).then(function (response) {\n    if (isNotRedirectedResponse(response)) {\n      return response;\n    }\n\n    // Fix already cached redirected responses\n    return fixRedirectedResponse(response).then(function (fixedResponse) {\n      return caches.open(cacheName).then(function (cache) {\n        return cache.put(request, fixedResponse);\n      }).then(function () {\n        return fixedResponse;\n      });\n    });\n  })\n  // Return void if error happened (cache not found)\n  ['catch'](function () {});\n}\n\nfunction applyCacheBust(asset, key) {\n  var hasQuery = asset.indexOf('?') !== -1;\n  return asset + (hasQuery ? '&' : '?') + '__uncache=' + encodeURIComponent(key);\n}\n\nfunction isNavigateRequest(request) {\n  return request.mode === 'navigate' || request.headers.get('Upgrade-Insecure-Requests') || (request.headers.get('Accept') || '').indexOf('text/html') !== -1;\n}\n\nfunction isNotRedirectedResponse(response) {\n  return !response || !response.redirected || !response.ok || response.type === 'opaqueredirect';\n}\n\n// Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85\nfunction fixRedirectedResponse(response) {\n  if (isNotRedirectedResponse(response)) {\n    return Promise.resolve(response);\n  }\n\n  var body = 'body' in response ? Promise.resolve(response.body) : response.blob();\n\n  return body.then(function (data) {\n    return new Response(data, {\n      headers: response.headers,\n      status: response.status\n    });\n  });\n}\n\nfunction copyObject(original) {\n  return Object.keys(original).reduce(function (result, key) {\n    result[key] = original[key];\n    return result;\n  }, {});\n}\n\nfunction logGroup(title, assets) {\n  console.groupCollapsed('[SW]:', title);\n\n  assets.forEach(function (asset) {\n    console.log('Asset:', asset);\n  });\n\n  console.groupEnd();\n}\n        WebpackServiceWorker(__wpo, {\nloaders: {},\ncacheMaps: [\n      {\n      match: function(url) {\n          if (url.pathname === location.pathname) {\n            return;\n          }\n\n          return new URL(\"/index.html\", location);\n        },\n      to: null,\n      requestTypes: [\"navigate\"],\n    }\n    ],\nnavigationPreload: false,\n});\n        module.exports = __webpack_require__(/*! ./empty-entry.js */ \"./node_modules/offline-plugin/tpls/empty-entry.js\")\n      //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2ZmbGluZS1wbHVnaW4vdHBscy9lbXB0eS1lbnRyeS5qcz9jYTlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRJQUE0STtBQUM1STtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QixtQkFBTyxDQUFDLDJFQUFrQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vZmZsaW5lLXBsdWdpbi9saWIvbWlzYy9zdy1sb2FkZXIuanM/anNvbj0lN0IlMjJkYXRhX3Zhcl9uYW1lJTIyJTNBJTIyX193cG8lMjIlMkMlMjJjYWNoZU1hcHMlMjIlM0ElNUIlN0IlMjJtYXRjaCUyMiUzQSUyMmZ1bmN0aW9uJTI4dXJsJTI5JTIwJTdCJTVDbiUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmJTIwJTI4dXJsLnBhdGhuYW1lJTIwJTNEJTNEJTNEJTIwbG9jYXRpb24ucGF0aG5hbWUlMjklMjAlN0IlNUNuJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwcmV0dXJuJTNCJTVDbiUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCU3RCU1Q24lNUNuJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwcmV0dXJuJTIwbmV3JTIwVVJMJTI4JTVDJTIyL2luZGV4Lmh0bWwlNUMlMjIlMkMlMjBsb2NhdGlvbiUyOSUzQiU1Q24lMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlN0QlMjIlMkMlMjJ0byUyMiUzQW51bGwlMkMlMjJyZXF1ZXN0VHlwZXMlMjIlM0ElNUIlMjJuYXZpZ2F0ZSUyMiU1RCU3RCU1RCUyQyUyMm5hdmlnYXRpb25QcmVsb2FkJTIyJTNBJTIyZmFsc2UlMjIlN0QhLi9ub2RlX21vZHVsZXMvb2ZmbGluZS1wbHVnaW4vdHBscy9lbXB0eS1lbnRyeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgd2FpdFVudGlsID0gRXh0ZW5kYWJsZUV2ZW50LnByb3RvdHlwZS53YWl0VW50aWw7XG4gIHZhciByZXNwb25kV2l0aCA9IEZldGNoRXZlbnQucHJvdG90eXBlLnJlc3BvbmRXaXRoO1xuICB2YXIgcHJvbWlzZXNNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gIEV4dGVuZGFibGVFdmVudC5wcm90b3R5cGUud2FpdFVudGlsID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgZXh0ZW5kYWJsZUV2ZW50ID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZXMgPSBwcm9taXNlc01hcC5nZXQoZXh0ZW5kYWJsZUV2ZW50KTtcblxuICAgIGlmIChwcm9taXNlcykge1xuICAgICAgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUocHJvbWlzZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb21pc2VzID0gW1Byb21pc2UucmVzb2x2ZShwcm9taXNlKV07XG4gICAgcHJvbWlzZXNNYXAuc2V0KGV4dGVuZGFibGVFdmVudCwgcHJvbWlzZXMpO1xuXG4gICAgLy8gY2FsbCBvcmlnaW5hbCBtZXRob2RcbiAgICByZXR1cm4gd2FpdFVudGlsLmNhbGwoZXh0ZW5kYWJsZUV2ZW50LCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uIHByb2Nlc3NQcm9taXNlcygpIHtcbiAgICAgIHZhciBsZW4gPSBwcm9taXNlcy5sZW5ndGg7XG5cbiAgICAgIC8vIHdhaXQgZm9yIGFsbCB0byBzZXR0bGVcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHBbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGhhdmUgbmV3IGl0ZW1zIGJlZW4gYWRkZWQ/IElmIHNvLCB3YWl0IGFnYWluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGggIT0gbGVuKSByZXR1cm4gcHJvY2Vzc1Byb21pc2VzKCk7XG4gICAgICAgIC8vIHdlJ3JlIGRvbmUhXG4gICAgICAgIHByb21pc2VzTWFwW1wiZGVsZXRlXCJdKGV4dGVuZGFibGVFdmVudCk7XG4gICAgICAgIC8vIHJlamVjdCBpZiBvbmUgb2YgdGhlIHByb21pc2VzIHJlamVjdGVkXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgRmV0Y2hFdmVudC5wcm90b3R5cGUucmVzcG9uZFdpdGggPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHRoaXMud2FpdFVudGlsKHByb21pc2UpO1xuICAgIHJldHVybiByZXNwb25kV2l0aC5jYWxsKHRoaXMsIHByb21pc2UpO1xuICB9O1xufSkoKTs7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBERUJVRyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIERFQlVHID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdlYnBhY2tTZXJ2aWNlV29ya2VyKHBhcmFtcywgaGVscGVycykge1xuICB2YXIgY2FjaGVNYXBzID0gaGVscGVycy5jYWNoZU1hcHM7XG4gIC8vIG5hdmlnYXRpb25QcmVsb2FkOiB0cnVlLCB7IG1hcDogKFVSTCkgPT4gVVJMLCB0ZXN0OiAoVVJMKSA9PiBib29sZWFuIH1cbiAgdmFyIG5hdmlnYXRpb25QcmVsb2FkID0gaGVscGVycy5uYXZpZ2F0aW9uUHJlbG9hZDtcblxuICAvLyAodXBkYXRlKXN0cmF0ZWd5OiBjaGFuZ2VkLCBhbGxcbiAgdmFyIHN0cmF0ZWd5ID0gcGFyYW1zLnN0cmF0ZWd5O1xuICAvLyByZXNwb25zZVN0cmF0ZWd5OiBjYWNoZS1maXJzdCwgbmV0d29yay1maXJzdFxuICB2YXIgcmVzcG9uc2VTdHJhdGVneSA9IHBhcmFtcy5yZXNwb25zZVN0cmF0ZWd5O1xuXG4gIHZhciBhc3NldHMgPSBwYXJhbXMuYXNzZXRzO1xuXG4gIHZhciBoYXNoZXNNYXAgPSBwYXJhbXMuaGFzaGVzTWFwO1xuICB2YXIgZXh0ZXJuYWxzID0gcGFyYW1zLmV4dGVybmFscztcblxuICB2YXIgcHJlZmV0Y2hSZXF1ZXN0ID0gcGFyYW1zLnByZWZldGNoUmVxdWVzdCB8fCB7XG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgbW9kZTogJ2NvcnMnXG4gIH07XG5cbiAgdmFyIENBQ0hFX1BSRUZJWCA9IHBhcmFtcy5uYW1lO1xuICB2YXIgQ0FDSEVfVEFHID0gcGFyYW1zLnZlcnNpb247XG4gIHZhciBDQUNIRV9OQU1FID0gQ0FDSEVfUFJFRklYICsgJzonICsgQ0FDSEVfVEFHO1xuXG4gIHZhciBQUkVMT0FEX0NBQ0hFX05BTUUgPSBDQUNIRV9QUkVGSVggKyAnJHByZWxvYWQnO1xuICB2YXIgU1RPUkVEX0RBVEFfS0VZID0gJ19fb2ZmbGluZV93ZWJwYWNrX19kYXRhJztcblxuICBtYXBBc3NldHMoKTtcblxuICB2YXIgYWxsQXNzZXRzID0gW10uY29uY2F0KGFzc2V0cy5tYWluLCBhc3NldHMuYWRkaXRpb25hbCwgYXNzZXRzLm9wdGlvbmFsKTtcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbGwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnSW5zdGFsbCBldmVudCcpO1xuXG4gICAgdmFyIGluc3RhbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc3RyYXRlZ3kgPT09ICdjaGFuZ2VkJykge1xuICAgICAgaW5zdGFsbGluZyA9IGNhY2hlQ2hhbmdlZCgnbWFpbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YWxsaW5nID0gY2FjaGVBc3NldHMoJ21haW4nKTtcbiAgICB9XG5cbiAgICBldmVudC53YWl0VW50aWwoaW5zdGFsbGluZyk7XG4gIH0pO1xuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZhdGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnQWN0aXZhdGUgZXZlbnQnKTtcblxuICAgIHZhciBhY3RpdmF0aW9uID0gY2FjaGVBZGRpdGlvbmFsKCk7XG5cbiAgICAvLyBEZWxldGUgYWxsIGFzc2V0cyB3aGljaCBuYW1lIHN0YXJ0cyB3aXRoIENBQ0hFX1BSRUZJWCBhbmRcbiAgICAvLyBpcyBub3QgY3VycmVudCBjYWNoZSAoQ0FDSEVfTkFNRSlcbiAgICBhY3RpdmF0aW9uID0gYWN0aXZhdGlvbi50aGVuKHN0b3JlQ2FjaGVEYXRhKTtcbiAgICBhY3RpdmF0aW9uID0gYWN0aXZhdGlvbi50aGVuKGRlbGV0ZU9ic29sZXRlKTtcbiAgICBhY3RpdmF0aW9uID0gYWN0aXZhdGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmNsaWVudHMgJiYgc2VsZi5jbGllbnRzLmNsYWltKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsaWVudHMuY2xhaW0oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChuYXZpZ2F0aW9uUHJlbG9hZCAmJiBzZWxmLnJlZ2lzdHJhdGlvbi5uYXZpZ2F0aW9uUHJlbG9hZCkge1xuICAgICAgYWN0aXZhdGlvbiA9IFByb21pc2UuYWxsKFthY3RpdmF0aW9uLCBzZWxmLnJlZ2lzdHJhdGlvbi5uYXZpZ2F0aW9uUHJlbG9hZC5lbmFibGUoKV0pO1xuICAgIH1cblxuICAgIGV2ZW50LndhaXRVbnRpbChhY3RpdmF0aW9uKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2FjaGVBZGRpdGlvbmFsKCkge1xuICAgIGlmICghYXNzZXRzLmFkZGl0aW9uYWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnQ2FjaGluZyBhZGRpdGlvbmFsJyk7XG4gICAgfVxuXG4gICAgdmFyIG9wZXJhdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChzdHJhdGVneSA9PT0gJ2NoYW5nZWQnKSB7XG4gICAgICBvcGVyYXRpb24gPSBjYWNoZUNoYW5nZWQoJ2FkZGl0aW9uYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gY2FjaGVBc3NldHMoJ2FkZGl0aW9uYWwnKTtcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgZmFpbCBvZiBgYWRkaXRpb25hbGAgY2FjaGUgc2VjdGlvblxuICAgIHJldHVybiBvcGVyYXRpb25bJ2NhdGNoJ10oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTV106JywgJ0NhY2hlIHNlY3Rpb24gYGFkZGl0aW9uYWxgIGZhaWxlZCB0byBsb2FkJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZUFzc2V0cyhzZWN0aW9uKSB7XG4gICAgdmFyIGJhdGNoID0gYXNzZXRzW3NlY3Rpb25dO1xuXG4gICAgcmV0dXJuIGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICByZXR1cm4gYWRkQWxsTm9ybWFsaXplZChjYWNoZSwgYmF0Y2gsIHtcbiAgICAgICAgYnVzdDogcGFyYW1zLnZlcnNpb24sXG4gICAgICAgIHJlcXVlc3Q6IHByZWZldGNoUmVxdWVzdCxcbiAgICAgICAgZmFpbEFsbDogc2VjdGlvbiA9PT0gJ21haW4nXG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZ0dyb3VwKCdDYWNoZWQgYXNzZXRzOiAnICsgc2VjdGlvbiwgYmF0Y2gpO1xuICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlQ2hhbmdlZChzZWN0aW9uKSB7XG4gICAgcmV0dXJuIGdldExhc3RDYWNoZSgpLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmICghYXJncykge1xuICAgICAgICByZXR1cm4gY2FjaGVBc3NldHMoc2VjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0Q2FjaGUgPSBhcmdzWzBdO1xuICAgICAgdmFyIGxhc3RLZXlzID0gYXJnc1sxXTtcbiAgICAgIHZhciBsYXN0RGF0YSA9IGFyZ3NbMl07XG5cbiAgICAgIHZhciBsYXN0TWFwID0gbGFzdERhdGEuaGFzaG1hcDtcbiAgICAgIHZhciBsYXN0VmVyc2lvbiA9IGxhc3REYXRhLnZlcnNpb247XG5cbiAgICAgIGlmICghbGFzdERhdGEuaGFzaG1hcCB8fCBsYXN0VmVyc2lvbiA9PT0gcGFyYW1zLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlQXNzZXRzKHNlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEhhc2hlZEFzc2V0cyA9IE9iamVjdC5rZXlzKGxhc3RNYXApLm1hcChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICByZXR1cm4gbGFzdE1hcFtoYXNoXTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbGFzdFVybHMgPSBsYXN0S2V5cy5tYXAoZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICAgICAgdXJsLnNlYXJjaCA9ICcnO1xuICAgICAgICB1cmwuaGFzaCA9ICcnO1xuXG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2VjdGlvbkFzc2V0cyA9IGFzc2V0c1tzZWN0aW9uXTtcbiAgICAgIHZhciBtb3ZlZCA9IFtdO1xuICAgICAgdmFyIGNoYW5nZWQgPSBzZWN0aW9uQXNzZXRzLmZpbHRlcihmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmIChsYXN0VXJscy5pbmRleE9mKHVybCkgPT09IC0xIHx8IGxhc3RIYXNoZWRBc3NldHMuaW5kZXhPZih1cmwpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5rZXlzKGhhc2hlc01hcCkuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICB2YXIgYXNzZXQgPSBoYXNoZXNNYXBbaGFzaF07XG5cbiAgICAgICAgLy8gUmV0dXJuIGlmIG5vdCBpbiBzZWN0aW9uQXNzZXRzIG9yIGluIGNoYW5nZWQgb3IgbW92ZWQgYXJyYXlcbiAgICAgICAgaWYgKHNlY3Rpb25Bc3NldHMuaW5kZXhPZihhc3NldCkgPT09IC0xIHx8IGNoYW5nZWQuaW5kZXhPZihhc3NldCkgIT09IC0xIHx8IG1vdmVkLmluZGV4T2YoYXNzZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBsYXN0QXNzZXQgPSBsYXN0TWFwW2hhc2hdO1xuXG4gICAgICAgIGlmIChsYXN0QXNzZXQgJiYgbGFzdFVybHMuaW5kZXhPZihsYXN0QXNzZXQpICE9PSAtMSkge1xuICAgICAgICAgIG1vdmVkLnB1c2goW2xhc3RBc3NldCwgYXNzZXRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2goYXNzZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbG9nR3JvdXAoJ0NoYW5nZWQgYXNzZXRzOiAnICsgc2VjdGlvbiwgY2hhbmdlZCk7XG4gICAgICBsb2dHcm91cCgnTW92ZWQgYXNzZXRzOiAnICsgc2VjdGlvbiwgbW92ZWQpO1xuXG4gICAgICB2YXIgbW92ZWRSZXNwb25zZXMgPSBQcm9taXNlLmFsbChtb3ZlZC5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgcmV0dXJuIGxhc3RDYWNoZS5tYXRjaChwYWlyWzBdKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiBbcGFpclsxXSwgcmVzcG9uc2VdO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgIHZhciBtb3ZlID0gbW92ZWRSZXNwb25zZXMudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3BvbnNlcy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5wdXQocGFpclswXSwgcGFpclsxXSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW21vdmUsIGFkZEFsbE5vcm1hbGl6ZWQoY2FjaGUsIGNoYW5nZWQsIHtcbiAgICAgICAgICBidXN0OiBwYXJhbXMudmVyc2lvbixcbiAgICAgICAgICByZXF1ZXN0OiBwcmVmZXRjaFJlcXVlc3QsXG4gICAgICAgICAgZmFpbEFsbDogc2VjdGlvbiA9PT0gJ21haW4nLFxuICAgICAgICAgIGRlbGV0ZUZpcnN0OiBzZWN0aW9uICE9PSAnbWFpbidcbiAgICAgICAgfSldKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlT2Jzb2xldGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlcy5rZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgdmFyIGFsbCA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKENBQ0hFX1BSRUZJWCkgIT09IDAgfHwga2V5LmluZGV4T2YoQ0FDSEVfTkFNRSkgPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnRGVsZXRlIGNhY2hlOicsIGtleSk7XG4gICAgICAgIHJldHVybiBjYWNoZXNbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFsbCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMYXN0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlcy5rZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcblxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoQ0FDSEVfUFJFRklYKSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5KSByZXR1cm47XG5cbiAgICAgIHZhciBjYWNoZSA9IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGNhY2hlcy5vcGVuKGtleSkudGhlbihmdW5jdGlvbiAoX2NhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gX2NhY2hlO1xuICAgICAgICByZXR1cm4gX2NhY2hlLm1hdGNoKG5ldyBVUkwoU1RPUkVEX0RBVEFfS0VZLCBsb2NhdGlvbikudG9TdHJpbmcoKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjYWNoZSwgY2FjaGUua2V5cygpLCByZXNwb25zZS5qc29uKCldKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcmVDYWNoZURhdGEoKSB7XG4gICAgcmV0dXJuIGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZlcnNpb246IHBhcmFtcy52ZXJzaW9uLFxuICAgICAgICBoYXNobWFwOiBoYXNoZXNNYXBcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGNhY2hlLnB1dChuZXcgVVJMKFNUT1JFRF9EQVRBX0tFWSwgbG9jYXRpb24pLnRvU3RyaW5nKCksIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdmZXRjaCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEhhbmRsZSBvbmx5IEdFVCByZXF1ZXN0c1xuICAgIGlmIChldmVudC5yZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHByZXZlbnRzIHNvbWUgd2VpcmQgaXNzdWUgd2l0aCBDaHJvbWUgRGV2VG9vbHMgYW5kICdvbmx5LWlmLWNhY2hlZCdcbiAgICAvLyBGaXhlcyBpc3N1ZSAjMzg1LCBhbHNvIHJlZiB0bzpcbiAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsaXJpc2gvY2FsdHJhaW5zY2hlZHVsZS5pby9pc3N1ZXMvNDlcbiAgICAvLyAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgyMzM5MlxuICAgIGlmIChldmVudC5yZXF1ZXN0LmNhY2hlID09PSAnb25seS1pZi1jYWNoZWQnICYmIGV2ZW50LnJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1cmwgPSBuZXcgVVJMKGV2ZW50LnJlcXVlc3QudXJsKTtcbiAgICB1cmwuaGFzaCA9ICcnO1xuXG4gICAgdmFyIHVybFN0cmluZyA9IHVybC50b1N0cmluZygpO1xuXG4gICAgLy8gTm90IGV4dGVybmFsLCBzbyBzZWFyY2ggcGFydCBvZiB0aGUgVVJMIHNob3VsZCBiZSBzdHJpcHBlZCxcbiAgICAvLyBpZiBpdCdzIGV4dGVybmFsIFVSTCwgdGhlIHNlYXJjaCBwYXJ0IHNob3VsZCBiZSBrZXB0XG4gICAgaWYgKGV4dGVybmFscy5pbmRleE9mKHVybFN0cmluZykgPT09IC0xKSB7XG4gICAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgICB1cmxTdHJpbmcgPSB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXRNYXRjaGVzID0gYWxsQXNzZXRzLmluZGV4T2YodXJsU3RyaW5nKSAhPT0gLTE7XG4gICAgdmFyIGNhY2hlVXJsID0gdXJsU3RyaW5nO1xuXG4gICAgaWYgKCFhc3NldE1hdGNoZXMpIHtcbiAgICAgIHZhciBjYWNoZVJld3JpdGUgPSBtYXRjaENhY2hlTWFwKGV2ZW50LnJlcXVlc3QpO1xuXG4gICAgICBpZiAoY2FjaGVSZXdyaXRlKSB7XG4gICAgICAgIGNhY2hlVXJsID0gY2FjaGVSZXdyaXRlO1xuICAgICAgICBhc3NldE1hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXNzZXRNYXRjaGVzKSB7XG4gICAgICAvLyBVc2UgcmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnIGluc3RlYWQgb2YgaXNOYXZpZ2F0ZVJlcXVlc3RcbiAgICAgIC8vIGJlY2F1c2UgZXZlcnl0aGluZyB3aGF0IHN1cHBvcnRzIG5hdmlnYXRpb25QcmVsb2FkIHN1cHBvcnRzXG4gICAgICAvLyAnbmF2aWdhdGUnIHJlcXVlc3QubW9kZVxuICAgICAgaWYgKGV2ZW50LnJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgICAvLyBSZXF1ZXN0aW5nIHdpdGggZmV0Y2hXaXRoUHJlbG9hZCgpLlxuICAgICAgICAvLyBQcmVsb2FkIGlzIHVzZWQgb25seSBpZiBuYXZpZ2F0aW9uUHJlbG9hZCBpcyBlbmFibGVkIGFuZFxuICAgICAgICAvLyBuYXZpZ2F0aW9uUHJlbG9hZCBtYXBwaW5nIGlzIG5vdCB1c2VkLlxuICAgICAgICBpZiAobmF2aWdhdGlvblByZWxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgICBldmVudC5yZXNwb25kV2l0aChmZXRjaFdpdGhQcmVsb2FkKGV2ZW50KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWV0aGluZyBlbHNlLCBwb3NpdGl2ZSwgYnV0IG5vdCBgdHJ1ZWBcbiAgICAgIGlmIChuYXZpZ2F0aW9uUHJlbG9hZCkge1xuICAgICAgICB2YXIgcHJlbG9hZGVkUmVzcG9uc2UgPSByZXRyaXZlUHJlbG9hZGVkUmVzcG9uc2UoZXZlbnQpO1xuXG4gICAgICAgIGlmIChwcmVsb2FkZWRSZXNwb25zZSkge1xuICAgICAgICAgIGV2ZW50LnJlc3BvbmRXaXRoKHByZWxvYWRlZFJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTG9naWMgZXhpc3RzIGhlcmUgaWYgbm8gY2FjaGUgbWF0Y2hcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWNoZSBoYW5kbGluZy9zdG9yaW5nL2ZldGNoaW5nIHN0YXJ0cyBoZXJlXG4gICAgdmFyIHJlc291cmNlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc3BvbnNlU3RyYXRlZ3kgPT09ICduZXR3b3JrLWZpcnN0Jykge1xuICAgICAgcmVzb3VyY2UgPSBuZXR3b3JrRmlyc3RSZXNwb25zZShldmVudCwgdXJsU3RyaW5nLCBjYWNoZVVybCk7XG4gICAgfVxuICAgIC8vICdjYWNoZS1maXJzdCcgb3RoZXJ3aXNlXG4gICAgLy8gKHJlc3BvbnNlU3RyYXRlZ3kgaGFzIGJlZW4gdmFsaWRhdGVkIGJlZm9yZSlcbiAgICBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2UgPSBjYWNoZUZpcnN0UmVzcG9uc2UoZXZlbnQsIHVybFN0cmluZywgY2FjaGVVcmwpO1xuICAgICAgfVxuXG4gICAgZXZlbnQucmVzcG9uZFdpdGgocmVzb3VyY2UpO1xuICB9KTtcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gICAgc3dpdGNoIChkYXRhLmFjdGlvbikge1xuICAgICAgY2FzZSAnc2tpcFdhaXRpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHNlbGYuc2tpcFdhaXRpbmcpIHNlbGYuc2tpcFdhaXRpbmcoKTtcbiAgICAgICAgfWJyZWFrO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2FjaGVGaXJzdFJlc3BvbnNlKGV2ZW50LCB1cmxTdHJpbmcsIGNhY2hlVXJsKSB7XG4gICAgaGFuZGxlTmF2aWdhdGlvblByZWxvYWQoZXZlbnQpO1xuXG4gICAgcmV0dXJuIGNhY2hlc01hdGNoKGNhY2hlVXJsLCBDQUNIRV9OQU1FKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU1ddOicsICdVUkwgWycgKyBjYWNoZVVybCArICddKCcgKyB1cmxTdHJpbmcgKyAnKSBmcm9tIGNhY2hlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgYW5kIGNhY2hlIGtub3duIGFzc2V0c1xuICAgICAgdmFyIGZldGNoaW5nID0gZmV0Y2goZXZlbnQucmVxdWVzdCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTV106JywgJ1VSTCBbJyArIHVybFN0cmluZyArICddIHdyb25nIHJlc3BvbnNlOiBbJyArIHJlc3BvbnNlLnN0YXR1cyArICddICcgKyByZXNwb25zZS50eXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnVVJMIFsnICsgdXJsU3RyaW5nICsgJ10gZnJvbSBuZXR3b3JrJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGVVcmwgPT09IHVybFN0cmluZykge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgc3RvcmluZyA9IGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZS5wdXQodXJsU3RyaW5nLCByZXNwb25zZUNsb25lKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NXXTonLCAnQ2FjaGUgYXNzZXQ6ICcgKyB1cmxTdHJpbmcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChzdG9yaW5nKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmZXRjaGluZztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ldHdvcmtGaXJzdFJlc3BvbnNlKGV2ZW50LCB1cmxTdHJpbmcsIGNhY2hlVXJsKSB7XG4gICAgcmV0dXJuIGZldGNoV2l0aFByZWxvYWQoZXZlbnQpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tTV106JywgJ1VSTCBbJyArIHVybFN0cmluZyArICddIGZyb20gbmV0d29yaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyB0byByZWFjaCB0aGUgY29kZSBpbiB0aGUgY2F0Y2ggYmVsb3dcbiAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgIH0pXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBpbiBhIGNhdGNoKCkgYW5kIG5vdCBqdXN0IGluIHRoZSB0aGVuKCkgYWJvdmVcbiAgICAvLyBjYXVzZSBpZiB5b3VyIG5ldHdvcmsgaXMgZG93biwgdGhlIGZldGNoKCkgd2lsbCB0aHJvd1xuICAgIFsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3JlZFJlc3BvbnNlKSB7XG4gICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTV106JywgJ1VSTCBbJyArIHVybFN0cmluZyArICddIGZyb20gY2FjaGUgaWYgcG9zc2libGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlc01hdGNoKGNhY2hlVXJsLCBDQUNIRV9OQU1FKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JlZFJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JlZFJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IGEgcmVzcG9uc2UgYXQgdGhpcyBwb2ludCwgc29tZSBvdGhlciBlcnJvclxuICAgICAgICB0aHJvdyBlcnJvcmVkUmVzcG9uc2U7XG4gICAgICAgIC8vIHJldHVybiBSZXNwb25zZS5lcnJvcigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOYXZpZ2F0aW9uUHJlbG9hZChldmVudCkge1xuICAgIGlmIChuYXZpZ2F0aW9uUHJlbG9hZCAmJiB0eXBlb2YgbmF2aWdhdGlvblByZWxvYWQubWFwID09PSAnZnVuY3Rpb24nICYmXG4gICAgLy8gVXNlIHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyBpbnN0ZWFkIG9mIGlzTmF2aWdhdGVSZXF1ZXN0XG4gICAgLy8gYmVjYXVzZSBldmVyeXRoaW5nIHdoYXQgc3VwcG9ydHMgbmF2aWdhdGlvblByZWxvYWQgc3VwcG9ydHNcbiAgICAvLyAnbmF2aWdhdGUnIHJlcXVlc3QubW9kZVxuICAgIGV2ZW50LnByZWxvYWRSZXNwb25zZSAmJiBldmVudC5yZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBuYXZpZ2F0aW9uUHJlbG9hZC5tYXAobmV3IFVSTChldmVudC5yZXF1ZXN0LnVybCksIGV2ZW50LnJlcXVlc3QpO1xuXG4gICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgIHN0b3JlUHJlbG9hZGVkUmVzcG9uc2UobWFwcGVkLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGVtcG9yYXJ5IGluLW1lbW9yeSBzdG9yZSBmb3IgZmFzdGVyIGFjY2Vzc1xuICB2YXIgbmF2aWdhdGlvblByZWxvYWRTdG9yZSA9IG5ldyBNYXAoKTtcblxuICBmdW5jdGlvbiBzdG9yZVByZWxvYWRlZFJlc3BvbnNlKF91cmwsIGV2ZW50KSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwoX3VybCwgbG9jYXRpb24pO1xuICAgIHZhciBwcmVsb2FkUmVzcG9uc2VQcm9taXNlID0gZXZlbnQucHJlbG9hZFJlc3BvbnNlO1xuXG4gICAgbmF2aWdhdGlvblByZWxvYWRTdG9yZS5zZXQocHJlbG9hZFJlc3BvbnNlUHJvbWlzZSwge1xuICAgICAgdXJsOiB1cmwsXG4gICAgICByZXNwb25zZTogcHJlbG9hZFJlc3BvbnNlUHJvbWlzZVxuICAgIH0pO1xuXG4gICAgdmFyIGlzU2FtZVByZWxvYWQgPSBmdW5jdGlvbiBpc1NhbWVQcmVsb2FkKCkge1xuICAgICAgcmV0dXJuIG5hdmlnYXRpb25QcmVsb2FkU3RvcmUuaGFzKHByZWxvYWRSZXNwb25zZVByb21pc2UpO1xuICAgIH07XG5cbiAgICB2YXIgc3RvcmluZyA9IHByZWxvYWRSZXNwb25zZVByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBSZXR1cm4gaWYgcHJlbG9hZCBpc24ndCBlbmFibGVkIG9yIGhhc24ndCBoYXBwZW5lZFxuICAgICAgaWYgKCFyZXMpIHJldHVybjtcblxuICAgICAgLy8gSWYgbmF2aWdhdGlvblByZWxvYWRTdG9yZSBhbHJlYWR5IGNvbnN1bWVkXG4gICAgICAvLyBvciBuYXZpZ2F0aW9uUHJlbG9hZFN0b3JlIGFscmVhZHkgY29udGFpbnMgYW5vdGhlciBwcmVsb2FkLFxuICAgICAgLy8gdGhlbiBkbyBub3Qgc3RvcmUgYW55dGhpbmcgYW5kIHJldHVyblxuICAgICAgaWYgKCFpc1NhbWVQcmVsb2FkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmUgPSByZXMuY2xvbmUoKTtcblxuICAgICAgLy8gU3RvcmluZyB0aGUgcHJlbG9hZCByZXNwb25zZSBmb3IgbGF0ZXIgY29uc3VtZSAoaGFzbid0IHlldCBiZWVuIGNvbnN1bWVkKVxuICAgICAgcmV0dXJuIGNhY2hlcy5vcGVuKFBSRUxPQURfQ0FDSEVfTkFNRSkudGhlbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKCFpc1NhbWVQcmVsb2FkKCkpIHJldHVybjtcblxuICAgICAgICByZXR1cm4gY2FjaGUucHV0KHVybCwgY2xvbmUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNTYW1lUHJlbG9hZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVzLm9wZW4oUFJFTE9BRF9DQUNIRV9OQU1FKS50aGVuKGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbJ2RlbGV0ZSddKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBldmVudC53YWl0VW50aWwoc3RvcmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXRyaXZlSW5NZW1vcnlQcmVsb2FkZWRSZXNwb25zZSh1cmwpIHtcbiAgICBpZiAoIW5hdmlnYXRpb25QcmVsb2FkU3RvcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZm91bmRSZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZm91bmRLZXkgPSB1bmRlZmluZWQ7XG5cbiAgICBuYXZpZ2F0aW9uUHJlbG9hZFN0b3JlLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgICAgIGlmIChzdG9yZS51cmwuaHJlZiA9PT0gdXJsLmhyZWYpIHtcbiAgICAgICAgZm91bmRSZXNwb25zZSA9IHN0b3JlLnJlc3BvbnNlO1xuICAgICAgICBmb3VuZEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChmb3VuZFJlc3BvbnNlKSB7XG4gICAgICBuYXZpZ2F0aW9uUHJlbG9hZFN0b3JlWydkZWxldGUnXShmb3VuZEtleSk7XG4gICAgICByZXR1cm4gZm91bmRSZXNwb25zZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXRyaXZlUHJlbG9hZGVkUmVzcG9uc2UoZXZlbnQpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChldmVudC5yZXF1ZXN0LnVybCk7XG5cbiAgICBpZiAoc2VsZi5yZWdpc3RyYXRpb24ubmF2aWdhdGlvblByZWxvYWQgJiYgbmF2aWdhdGlvblByZWxvYWQgJiYgbmF2aWdhdGlvblByZWxvYWQudGVzdCAmJiBuYXZpZ2F0aW9uUHJlbG9hZC50ZXN0KHVybCwgZXZlbnQucmVxdWVzdCkpIHt9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcm9tTWVtb3J5ID0gcmV0cml2ZUluTWVtb3J5UHJlbG9hZGVkUmVzcG9uc2UodXJsKTtcbiAgICB2YXIgcmVxdWVzdCA9IGV2ZW50LnJlcXVlc3Q7XG5cbiAgICBpZiAoZnJvbU1lbW9yeSkge1xuICAgICAgZXZlbnQud2FpdFVudGlsKGNhY2hlcy5vcGVuKFBSRUxPQURfQ0FDSEVfTkFNRSkudGhlbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlWydkZWxldGUnXShyZXF1ZXN0KTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGZyb21NZW1vcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlc01hdGNoKHJlcXVlc3QsIFBSRUxPQURfQ0FDSEVfTkFNRSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICBldmVudC53YWl0VW50aWwoY2FjaGVzLm9wZW4oUFJFTE9BRF9DQUNIRV9OQU1FKS50aGVuKGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZVsnZGVsZXRlJ10ocmVxdWVzdCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlIHx8IGZldGNoKGV2ZW50LnJlcXVlc3QpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwQXNzZXRzKCkge1xuICAgIE9iamVjdC5rZXlzKGFzc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBhc3NldHNba2V5XSA9IGFzc2V0c1trZXldLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgdXJsID0gbmV3IFVSTChwYXRoLCBsb2NhdGlvbik7XG5cbiAgICAgICAgdXJsLmhhc2ggPSAnJztcblxuICAgICAgICBpZiAoZXh0ZXJuYWxzLmluZGV4T2YocGF0aCkgPT09IC0xKSB7XG4gICAgICAgICAgdXJsLnNlYXJjaCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBoYXNoZXNNYXAgPSBPYmplY3Qua2V5cyhoYXNoZXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBoYXNoKSB7XG4gICAgICB2YXIgdXJsID0gbmV3IFVSTChoYXNoZXNNYXBbaGFzaF0sIGxvY2F0aW9uKTtcbiAgICAgIHVybC5zZWFyY2ggPSAnJztcbiAgICAgIHVybC5oYXNoID0gJyc7XG5cbiAgICAgIHJlc3VsdFtoYXNoXSA9IHVybC50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICBleHRlcm5hbHMgPSBleHRlcm5hbHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgdXJsID0gbmV3IFVSTChwYXRoLCBsb2NhdGlvbik7XG4gICAgICB1cmwuaGFzaCA9ICcnO1xuXG4gICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRBbGxOb3JtYWxpemVkKGNhY2hlLCByZXF1ZXN0cywgb3B0aW9ucykge1xuICAgIHZhciBidXN0VmFsdWUgPSBvcHRpb25zLmJ1c3Q7XG4gICAgdmFyIGZhaWxBbGwgPSBvcHRpb25zLmZhaWxBbGwgIT09IGZhbHNlO1xuICAgIHZhciBkZWxldGVGaXJzdCA9IG9wdGlvbnMuZGVsZXRlRmlyc3QgPT09IHRydWU7XG4gICAgdmFyIHJlcXVlc3RJbml0ID0gb3B0aW9ucy5yZXF1ZXN0IHx8IHtcbiAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcsXG4gICAgICBtb2RlOiAnY29ycydcbiAgICB9O1xuXG4gICAgdmFyIGRlbGV0aW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBpZiAoZGVsZXRlRmlyc3QpIHtcbiAgICAgIGRlbGV0aW5nID0gUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBjYWNoZVsnZGVsZXRlJ10ocmVxdWVzdClbJ2NhdGNoJ10oZnVuY3Rpb24gKCkge30pO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChyZXF1ZXN0cy5tYXAoZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgIGlmIChidXN0VmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdCA9IGFwcGx5Q2FjaGVCdXN0KHJlcXVlc3QsIGJ1c3RWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZXRjaChyZXF1ZXN0LCByZXF1ZXN0SW5pdCkudGhlbihmaXhSZWRpcmVjdGVkUmVzcG9uc2UpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVzcG9uc2U6IHJlc3BvbnNlIH07XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlIH07XG4gICAgICB9KTtcbiAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7XG4gICAgICBpZiAoZmFpbEFsbCAmJiByZXNwb25zZXMuc29tZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5lcnJvcjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dyb25nIHJlc3BvbnNlIHN0YXR1cycpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmYWlsQWxsKSB7XG4gICAgICAgIHJlc3BvbnNlcyA9IHJlc3BvbnNlcy5maWx0ZXIoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gIWRhdGEuZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZXRpbmcudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRBbGwgPSByZXNwb25zZXMubWFwKGZ1bmN0aW9uIChfcmVmLCBpKSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0gX3JlZi5yZXNwb25zZTtcblxuICAgICAgICAgIHJldHVybiBjYWNoZS5wdXQocmVxdWVzdHNbaV0sIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFkZEFsbCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoQ2FjaGVNYXAocmVxdWVzdCkge1xuICAgIHZhciB1cmxTdHJpbmcgPSByZXF1ZXN0LnVybDtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuXG4gICAgdmFyIHJlcXVlc3RUeXBlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzTmF2aWdhdGVSZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICByZXF1ZXN0VHlwZSA9ICduYXZpZ2F0ZSc7XG4gICAgfSBlbHNlIGlmICh1cmwub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgIHJlcXVlc3RUeXBlID0gJ3NhbWUtb3JpZ2luJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdFR5cGUgPSAnY3Jvc3Mtb3JpZ2luJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlTWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcCA9IGNhY2hlTWFwc1tpXTtcblxuICAgICAgaWYgKCFtYXApIGNvbnRpbnVlO1xuICAgICAgaWYgKG1hcC5yZXF1ZXN0VHlwZXMgJiYgbWFwLnJlcXVlc3RUeXBlcy5pbmRleE9mKHJlcXVlc3RUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbWFwLm1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5ld1N0cmluZyA9IG1hcC5tYXRjaCh1cmwsIHJlcXVlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UobWFwLm1hdGNoLCBtYXAudG8pO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3U3RyaW5nICYmIG5ld1N0cmluZyAhPT0gdXJsU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXdTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hXaXRoUHJlbG9hZChldmVudCkge1xuICAgIGlmICghZXZlbnQucHJlbG9hZFJlc3BvbnNlIHx8IG5hdmlnYXRpb25QcmVsb2FkICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmV0Y2goZXZlbnQucmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LnByZWxvYWRSZXNwb25zZS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlIHx8IGZldGNoKGV2ZW50LnJlcXVlc3QpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlc01hdGNoKHJlcXVlc3QsIGNhY2hlTmFtZSkge1xuICByZXR1cm4gY2FjaGVzLm1hdGNoKHJlcXVlc3QsIHtcbiAgICBjYWNoZU5hbWU6IGNhY2hlTmFtZVxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmIChpc05vdFJlZGlyZWN0ZWRSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICAvLyBGaXggYWxyZWFkeSBjYWNoZWQgcmVkaXJlY3RlZCByZXNwb25zZXNcbiAgICByZXR1cm4gZml4UmVkaXJlY3RlZFJlc3BvbnNlKHJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uIChmaXhlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVzLm9wZW4oY2FjaGVOYW1lKS50aGVuKGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGUucHV0KHJlcXVlc3QsIGZpeGVkUmVzcG9uc2UpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmaXhlZFJlc3BvbnNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pXG4gIC8vIFJldHVybiB2b2lkIGlmIGVycm9yIGhhcHBlbmVkIChjYWNoZSBub3QgZm91bmQpXG4gIFsnY2F0Y2gnXShmdW5jdGlvbiAoKSB7fSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q2FjaGVCdXN0KGFzc2V0LCBrZXkpIHtcbiAgdmFyIGhhc1F1ZXJ5ID0gYXNzZXQuaW5kZXhPZignPycpICE9PSAtMTtcbiAgcmV0dXJuIGFzc2V0ICsgKGhhc1F1ZXJ5ID8gJyYnIDogJz8nKSArICdfX3VuY2FjaGU9JyArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xufVxuXG5mdW5jdGlvbiBpc05hdmlnYXRlUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgfHwgcmVxdWVzdC5oZWFkZXJzLmdldCgnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cycpIHx8IChyZXF1ZXN0LmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSB8fCAnJykuaW5kZXhPZigndGV4dC9odG1sJykgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc05vdFJlZGlyZWN0ZWRSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5yZWRpcmVjdGVkIHx8ICFyZXNwb25zZS5vayB8fCByZXNwb25zZS50eXBlID09PSAnb3BhcXVlcmVkaXJlY3QnO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3N3LXByZWNhY2hlL3B1bGwvMjQxL2ZpbGVzI2RpZmYtM2VlOTA2MGRjN2EzMTJjNmE4MjJjYWM2M2E4YzYzMGJSODVcbmZ1bmN0aW9uIGZpeFJlZGlyZWN0ZWRSZXNwb25zZShyZXNwb25zZSkge1xuICBpZiAoaXNOb3RSZWRpcmVjdGVkUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gIH1cblxuICB2YXIgYm9keSA9ICdib2R5JyBpbiByZXNwb25zZSA/IFByb21pc2UucmVzb2x2ZShyZXNwb25zZS5ib2R5KSA6IHJlc3BvbnNlLmJsb2IoKTtcblxuICByZXR1cm4gYm9keS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShkYXRhLCB7XG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvcHlPYmplY3Qob3JpZ2luYWwpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9yaWdpbmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSBvcmlnaW5hbFtrZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAodGl0bGUsIGFzc2V0cykge1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdbU1ddOicsIHRpdGxlKTtcblxuICBhc3NldHMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICBjb25zb2xlLmxvZygnQXNzZXQ6JywgYXNzZXQpO1xuICB9KTtcblxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG4gICAgICAgIFdlYnBhY2tTZXJ2aWNlV29ya2VyKF9fd3BvLCB7XG5sb2FkZXJzOiB7fSxcbmNhY2hlTWFwczogW1xuICAgICAge1xuICAgICAgbWF0Y2g6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09IGxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBVUkwoXCIvaW5kZXguaHRtbFwiLCBsb2NhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICB0bzogbnVsbCxcbiAgICAgIHJlcXVlc3RUeXBlczogW1wibmF2aWdhdGVcIl0sXG4gICAgfVxuICAgIF0sXG5uYXZpZ2F0aW9uUHJlbG9hZDogZmFsc2UsXG59KTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9lbXB0eS1lbnRyeS5qc1wiKVxuICAgICAgIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/index.html%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./node_modules/offline-plugin/tpls/empty-entry.js\n");

/***/ }),

/***/ "./node_modules/offline-plugin/tpls/empty-entry.js":
/*!*********************************************************!*\
  !*** ./node_modules/offline-plugin/tpls/empty-entry.js ***!
  \*********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vZmZsaW5lLXBsdWdpbi90cGxzL2VtcHR5LWVudHJ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/offline-plugin/tpls/empty-entry.js\n");

/***/ })

/******/ });